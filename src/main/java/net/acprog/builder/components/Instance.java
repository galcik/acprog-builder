package net.acprog.builder.components;

import java.util.*;

import net.acprog.builder.compilation.CompilationException;
import net.acprog.builder.modules.ComponentType;
import net.acprog.builder.platform.Platform;
import net.acprog.builder.project.Component;
import net.acprog.builder.utils.XmlUtils;

import org.w3c.dom.Element;

/**
 * Description of a class instance (e.g., view, controller, ...).
 */
public class Instance {

    // ---------------------------------------------------------------------------
    // ArgumentType
    // ---------------------------------------------------------------------------

    /**
     * Type of an argument.
     */
    public static enum ArgumentType {
	/**
	 * Property defined by a given context.
	 */
	PROPERTY,
	/**
	 * Fixed value.
	 */
	VALUE,
	/**
	 * Fixed string value
	 */
	STR_VALUE,
	/**
	 * Fixed flash string value
	 */
	FSTR_VALUE,
	/**
	 * Internal value auto-generated during compilation.
	 */
	AUTOGENERATED
    }

    // ---------------------------------------------------------------------------
    // Argument
    // ---------------------------------------------------------------------------

    /**
     * Description of an argument (of constructor, method, etc.).
     */
    public static class Argument {
	private final ArgumentType type;
	private final String value;

	public ArgumentType getType() {
	    return type;
	}

	public String getValue() {
	    return value;
	}

	public Argument(ArgumentType type, String value) {
	    this.type = type;
	    this.value = value;
	}
    }

    // ---------------------------------------------------------------------------
    // Method
    // ---------------------------------------------------------------------------

    /**
     * Description of a method.
     */
    public class Method {
	/**
	 * Name of the method.
	 */
	private final String name;

	/**
	 * List of arguments.
	 */
	private final List<Argument> arguments = new ArrayList<Argument>();

	/**
	 * Constructs a method description
	 * 
	 * @param name
	 */
	public Method(String name) {
	    this.name = name;
	}

	/**
	 * Generates method invocation code.
	 * 
	 * @param objectName
	 *            the name of object.
	 * @param componentConfig
	 *            the component configuration.
	 * @param platform
	 *            target hardware and compilation platform.
	 * @return the code that executes the method.
	 */
	public String generateInvocationCode(String objectName, Component componentConfig, Platform platform) {
	    return objectName + "." + name + "(" + generateArgumentList(arguments, componentConfig, platform) + ");";
	}
    }

    // ---------------------------------------------------------------------------
    // Instance variables
    // ---------------------------------------------------------------------------

    /**
     * Component type to which this instance description belongs.
     */
    private final ComponentType componentType;

    /**
     * Name of a class (including namespace) that provides implementation of the
     * instance.
     */
    private String className;

    /**
     * List of includes required to create the instance.
     */
    private final List<String> includes = new ArrayList<String>();

    /**
     * Ordered list of template arguments.
     */
    private final List<Argument> templateArguments = new ArrayList<Argument>();

    /**
     * Ordered list of constructor arguments.
     */
    private final List<Argument> constructorArguments = new ArrayList<Argument>();

    /**
     * Init method
     */
    private Method initMethod;

    /**
     * Loop method
     */
    private Method loopMethod;

    // ---------------------------------------------------------------------------
    // Setters and getters
    // ---------------------------------------------------------------------------

    /**
     * Gets name of a class (including namespace) that provides implementation
     * of the instance.
     */
    public String getClassName() {
	return className;
    }

    /**
     * Sets name of a class (including namespace) that provides implementation
     * of the instance.
     */
    public void setClassName(String className) {
	this.className = className;
    }

    /**
     * Gets the list of includes required to create the instance.
     */
    public List<String> getIncludes() {
	return includes;
    }

    /**
     * Gets the list of template arguments.
     */
    public List<Argument> getTemplateArguments() {
	return templateArguments;
    }

    /**
     * Gets the list of constructor arguments.
     */
    public List<Argument> getConstructorArguments() {
	return constructorArguments;
    }

    public Method getInitMethod() {
	return initMethod;
    }

    public void setInitMethod(Method initMethod) {
	this.initMethod = initMethod;
    }

    public Method getLoopMethod() {
	return loopMethod;
    }

    public void setLoopMethod(Method loopMethod) {
	this.loopMethod = loopMethod;
    }

    // ---------------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------------

    /**
     * Construct an instance description for the component.
     * 
     * @param componentType
     *            the description of the component type.
     */
    public Instance(ComponentType componentType) {
	this.componentType = componentType;
    }

    // ---------------------------------------------------------------------------
    // XML parsing and validation
    // ---------------------------------------------------------------------------

    /**
     * Reads configuration of an instance from an xml element.
     * 
     * @param xmlElement
     *            the xml element.
     */
    public void readFromXml(Element xmlElement) {
	// Read includes
	includes.clear();
	Element xmlIncludes = XmlUtils.getChildElement(xmlElement, "includes");
	if (xmlIncludes != null) {
	    for (Element includeElement : XmlUtils.getChildElements(xmlIncludes, "include")) {
		String includePath = includeElement.getTextContent().trim();
		if (!includePath.isEmpty()) {
		    includes.add(includePath);
		}
	    }
	}

	// Read class name
	className = XmlUtils.getSimplePropertyValue(xmlElement, "class", "").trim();
	if (className.isEmpty()) {
	    throw new ConfigurationException("Instance must contains non-empty class name.");
	}

	// Read template arguments
	templateArguments.clear();
	loadXmlArguments(XmlUtils.getChildElement(xmlElement, "template-args"), "arg", templateArguments,
		"template argument");

	// Read constructor arguments
	constructorArguments.clear();
	loadXmlArguments(XmlUtils.getChildElement(xmlElement, "constructor-args"), "arg", constructorArguments,
		"constructor argument");

	// Init method
	initMethod = loadXmlMethod(XmlUtils.getChildElement(xmlElement, "init"));

	// Loop method
	loopMethod = loadXmlMethod(XmlUtils.getChildElement(xmlElement, "loop"));
    }

    /**
     * Loads argument descriptions from a given xml element.
     * 
     * @param xmlElement
     *            the argument container.
     * @param argElementName
     *            the name of element containing an argument definition
     * @param result
     *            the list to which arguments are passed
     * @param argTypeLabel
     *            the label for arguments (used to generate messages of
     *            exceptions)
     */
    private void loadXmlArguments(Element xmlElement, String argElementName, List<Argument> result, String argTypeLabel) {
	if (xmlElement == null) {
	    return;
	}

	for (Element xmlArg : XmlUtils.getChildElements(xmlElement, argElementName)) {
	    ArgumentType argType = null;
	    String argTypeCode = xmlArg.getAttribute("type").trim();
	    try {
		argType = ArgumentType.valueOf(argTypeCode.toUpperCase());
	    } catch (Exception e) {
		throw new ConfigurationException("Unknown type (" + argTypeCode + ") of " + argTypeLabel + ".");
	    }

	    String argValue = xmlArg.getTextContent().trim();
	    if (argValue.isEmpty()) {
		throw new ConfigurationException("Value of " + argTypeLabel + " cannot be empty.");
	    }

	    result.add(new Argument(argType, argValue));
	}
    }

    /**
     * Loads a method description from an xml element.
     * 
     * @param xmlElement
     *            the xml element containg method description
     * @return the constructed method description
     */
    private Method loadXmlMethod(Element xmlElement) {
	if (xmlElement == null) {
	    return null;
	}

	String methodName = null;
	Element xmlName = XmlUtils.getChildElement(xmlElement, "method");
	if (xmlName != null) {
	    methodName = xmlName.getTextContent().trim();
	}

	if ((methodName == null) || (methodName.isEmpty())) {
	    throw new ConfigurationException("The element " + xmlElement.getNodeName()
		    + " does not contain the method name.");
	}

	Method result = new Method(methodName);
	loadXmlArguments(xmlElement, "arg", result.arguments, "method argument (" + xmlElement.getNodeName() + ")");
	return result;
    }

    /**
     * Validates configuration with respect to given component type description.
     */
    public void validate(ComponentType component) {
	if ((className == null) || (className.trim().isEmpty())) {
	    throw new ConfigurationException("Instance class name cannot be null or empty.");
	}

	for (Argument ca : constructorArguments) {
	    if ((ca.value == null) || (ca.value.trim().isEmpty())) {
		throw new ConfigurationException("Instance definition contains a template argument with empty value.");
	    }

	    if (ca.type == null) {
		throw new ConfigurationException(
			"Instance definition contains a template argument without argument type.");
	    }

	    if ((ca.type == ArgumentType.PROPERTY) && (!component.getProperties().containsKey(ca.value))) {
		throw new ConfigurationException(
			"Instance definition contains a template argument with unknown property: " + ca.value);
	    }
	}
    }

    // ---------------------------------------------------------------------------
    // Generators
    // ---------------------------------------------------------------------------

    /**
     * Generates class type applying component configuration.
     * 
     * @param componentConfig
     *            the component configuration.
     * @param platform
     *            target hardware and compilation platform.
     * @return the class name or null, if the class name cannot be generated.
     */
    public String generateClassType(Component componentConfig, Platform platform) {
	if (templateArguments.isEmpty()) {
	    return getClassName();
	}

	return getClassName() + "<" + generateArgumentList(templateArguments, componentConfig, platform) + ">";
    }

    /**
     * Generates constructor arguments with respect to given component
     * configuration.
     * 
     * @param componentConfig
     *            the component configuration.
     * @param platform
     *            target hardware and compilation platform.
     * @return the string with comma separated constructor parameters.
     */
    public String generateConstructorArguments(Component componentConfig, Platform platform) {
	if (constructorArguments.isEmpty()) {
	    return "";
	}

	return "(" + generateArgumentList(constructorArguments, componentConfig, platform) + ")";
    }

    /**
     * Generates argument list.
     * 
     * @param arguments
     *            the list of arguments
     * @param componentConfig
     *            the component configuration.
     * @param platform
     *            target hardware and compilation platform.
     * @return the string containing list of arguments for invocation
     */
    private String generateArgumentList(List<Argument> arguments, Component componentConfig, Platform platform) {
	if ((arguments == null) || (arguments.isEmpty())) {
	    return "";
	}

	StringBuilder sb = new StringBuilder();
	boolean first = true;
	for (Argument arg : arguments) {
	    if (!first) {
		sb.append(", ");
	    } else {
		first = false;
	    }

	    if (arg.type == ArgumentType.VALUE) {
		sb.append(arg.value.trim());
	    } else if (arg.type == ArgumentType.STR_VALUE) {
		sb.append("\"");
		sb.append(arg.value);
		sb.append("\"");
	    } else if (arg.type == ArgumentType.FSTR_VALUE) {
		sb.append("F(\"");
		sb.append(arg.value);
		sb.append("\")");
	    } else if (arg.type == ArgumentType.PROPERTY) {
		PropertyType propType = componentType.getProperties().get(arg.value);
		if (propType == null) {
		    throw new CompilationException("Unknown property '" + arg.value + "' of component '"
			    + componentConfig.getName() + "' (caused by configuration error of component type).");
		}

		String effectivePropValue = propType.getEffectiveValue(componentConfig.getProperties().get(arg.value));
		String escapedPropValue = platform.escapeValue(propType.getType(), effectivePropValue);
		if (escapedPropValue == null) {
		    throw new CompilationException("Invalid or undefined value of property '" + arg.value
			    + "' of component '" + componentConfig.getName() + "'.");
		}

		// Add value to argument list
		sb.append(escapedPropValue);
	    } else if (arg.type == ArgumentType.AUTOGENERATED) {
		String propValue = componentConfig.getAutogeneratedProperties().get(arg.value);
		if ((propValue == null) || (propValue.trim().isEmpty())) {
		    throw new CompilationException("Undefined autogenerated property '" + arg.value
			    + "' of component '" + componentConfig.getName()
			    + "' (caused by configuration error of component type).");
		}
		sb.append(propValue);
	    }
	}

	return sb.toString();
    }
}
